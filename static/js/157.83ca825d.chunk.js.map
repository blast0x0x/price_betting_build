{"version":3,"file":"static/js/157.83ca825d.chunk.js","mappings":"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","sources":["../node_modules/viem/actions/wallet/sendTransaction.ts","../node_modules/viem/utils/chain/assertCurrentChain.ts","../node_modules/viem/utils/errors/getTransactionError.ts","../node_modules/viem/actions/wallet/writeContract.ts","../node_modules/@wagmi/core/src/query/writeContract.ts","../node_modules/@wagmi/core/src/actions/writeContract.ts","../node_modules/wagmi/src/hooks/useWriteContract.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/utils/properties.ts","../node_modules/ethers/src.ts/utils/errors.ts","../node_modules/ethers/src.ts/utils/data.ts","../node_modules/ethers/src.ts/utils/maths.ts","../node_modules/ethers/src.ts/utils/fixednumber.ts","../node_modules/ethers/src.ts/utils/units.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../experimental/eip7702/utils/recoverAuthorizationAddress.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { GetChainParameter } from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  defaultParameters,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionErrorType,\n  sendRawTransaction,\n} from './sendRawTransaction.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SendTransactionReturnType = Hash\n\nexport type SendTransactionErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | RequestErrorType\n    >\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value,\n    ...rest\n  } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format({\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        accessList,\n        authorizationList,\n        blobs,\n        chainId,\n        data,\n        from: account?.address,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n      } as TransactionRequest)\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      try {\n        return await client.request(\n          {\n            method,\n            params: [request],\n          },\n          { retryCount: 0 },\n        )\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e\n\n        const error = e as BaseError\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (\n          error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError'\n        ) {\n          return await client\n            .request(\n              {\n                method: 'wallet_sendTransaction',\n                params: [request],\n              },\n              { retryCount: 0 },\n            )\n            .then((hash) => {\n              supportsWalletNamespace.set(client.uid, true)\n              return hash\n            })\n            .catch((e) => {\n              const walletNamespaceError = e as BaseError\n              if (\n                walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                walletNamespaceError.name === 'MethodNotSupportedRpcError'\n              ) {\n                supportsWalletNamespace.set(client.uid, false)\n                throw error\n              }\n\n              throw walletNamespaceError\n            })\n        }\n\n        throw error\n      }\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return await getAction(\n        client,\n        sendRawTransaction,\n        'sendRawTransaction',\n      )({\n        serializedTransaction,\n      })\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n","import {\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain | undefined\n  currentChainId: number\n}\n\nexport type AssertCurrentChainErrorType =\n  | ChainNotFoundErrorType\n  | ChainMismatchErrorType\n  | ErrorType\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport {\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetTransactionErrorParameters = Omit<\n  SendTransactionParameters,\n  'account' | 'chain'\n> & {\n  account: Account | null\n  chain?: Chain | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetTransactionErrorReturnType<cause = ErrorType> = Omit<\n  TransactionExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getTransactionError<err extends ErrorType<string>>(\n  err: err,\n  { docsPath, ...args }: GetTransactionErrorParameters,\n): GetTransactionErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetTransactionErrorReturnType<err>\n}\n","import type { Abi, Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { GetMutabilityAwareValue } from '../public/simulateContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args,\n  false,\n  allFunctionNames\n> &\n  GetChainParameter<chain, chainOverride> &\n  Prettify<\n    GetAccountParameter<account, Account | Address, true, true> &\n      GetMutabilityAwareValue<\n        abi,\n        'nonpayable' | 'payable',\n        functionName,\n        FormattedTransactionRequest<derivedChain>['value'],\n        args\n      > & {\n        /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n        dataSuffix?: Hex | undefined\n      }\n  > &\n  UnionEvaluate<\n    UnionOmit<\n      FormattedTransactionRequest<derivedChain>,\n      'data' | 'from' | 'to' | 'value'\n    >\n  >\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport type WriteContractErrorType =\n  | EncodeFunctionDataErrorType\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetContractErrorReturnType<SendTransactionErrorType>\n  | ErrorType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  const {\n    abi,\n    account: account_ = client.account,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...request\n  } = parameters as WriteContractParameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/contract/writeContract',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n\n  try {\n    return await getAction(\n      client,\n      sendTransaction,\n      'sendTransaction',\n    )({\n      data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      account,\n      ...request,\n    })\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/writeContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n","import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../actions/writeContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function writeContractMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return writeContract(config, variables)\n    },\n    mutationKey: ['writeContract'],\n  } as const satisfies MutationOptions<\n    WriteContractData,\n    WriteContractErrorType,\n    WriteContractVariables<\n      Abi,\n      string,\n      readonly unknown[],\n      config,\n      config['chains'][number]['id']\n    >\n  >\n}\n\nexport type WriteContractData = Compute<WriteContractReturnType>\n\nexport type WriteContractVariables<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  allFunctionNames\n>\n\nexport type WriteContractMutate<config extends Config, context = unknown> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type WriteContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => Promise<WriteContractData>\n","import type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from 'viem'\nimport {\n  type WriteContractErrorType as viem_WriteContractErrorType,\n  type WriteContractParameters as viem_WriteContractParameters,\n  type WriteContractReturnType as viem_WriteContractReturnType,\n  writeContract as viem_writeContract,\n} from 'viem/actions'\n\nimport type { Config } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport type { SelectChains } from '../types/chain.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute, UnionCompute } from '../types/utils.js'\nimport { getAction } from '../utils/getAction.js'\nimport {\n  type GetConnectorClientErrorType,\n  getConnectorClient,\n} from './getConnectorClient.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  chains extends readonly Chain[] = SelectChains<config, chainId>,\n> = UnionCompute<\n  {\n    // TODO: Should use `UnionStrictOmit<..., 'chain'>` on `viem_WriteContractParameters` result instead\n    // temp workaround that doesn't affect runtime behavior for for https://github.com/wevm/wagmi/issues/3981\n    [key in keyof chains]: viem_WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chains[key],\n      Account,\n      chains[key],\n      allFunctionNames\n    >\n  }[number] &\n    Compute<ChainIdParameter<config, chainId>> &\n    ConnectorParameter & {\n      /** @deprecated */\n      __mode?: 'prepared'\n    }\n>\n\nexport type WriteContractReturnType = viem_WriteContractReturnType\n\nexport type WriteContractErrorType =\n  // getConnectorClient()\n  | GetConnectorClientErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n  // viem\n  | viem_WriteContractErrorType\n\n/** https://wagmi.sh/core/api/actions/writeContract */\nexport async function writeContract<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: WriteContractParameters<abi, functionName, args, config, chainId>,\n): Promise<WriteContractReturnType> {\n  const { account, chainId, connector, ...request } = parameters\n\n  let client: Client\n  if (typeof account === 'object' && account?.type === 'local')\n    client = config.getClient({ chainId })\n  else\n    client = await getConnectorClient(config, {\n      account: account ?? undefined,\n      chainId,\n      connector,\n    })\n\n  const action = getAction(client, viem_writeContract, 'writeContract')\n  const hash = await action({\n    ...(request as any),\n    ...(account ? { account } : {}),\n    chain: chainId ? { id: chainId } : null,\n  })\n\n  return hash\n}\n","'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  WriteContractErrorType,\n} from '@wagmi/core'\nimport {\n  type WriteContractData,\n  type WriteContractMutate,\n  type WriteContractMutateAsync,\n  type WriteContractVariables,\n  writeContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWriteContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = ConfigParameter<config> & {\n  mutation?:\n    | UseMutationParameters<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          Abi,\n          string,\n          readonly unknown[],\n          config,\n          config['chains'][number]['id']\n        >,\n        context\n      >\n    | undefined\n}\n\nexport type UseWriteContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context\n> & {\n  writeContract: WriteContractMutate<config, context>\n  writeContractAsync: WriteContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/react/api/hooks/useWriteContract */\nexport function useWriteContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseWriteContractParameters<config, context> = {},\n): UseWriteContractReturnType<config, context> {\n  const { mutation } = parameters\n\n  const config = useConfig(parameters)\n\n  const mutationOptions = writeContractMutationOptions(config)\n  const { mutate, mutateAsync, ...result } = useMutation({\n    ...mutation,\n    ...mutationOptions,\n  })\n\n  type Return = UseWriteContractReturnType<config, context>\n  return {\n    ...result,\n    writeContract: mutate as Return['writeContract'],\n    writeContractAsync: mutateAsync as Return['writeContractAsync'],\n  }\n}\n","/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n\n/**\n *  The current version of Ethers.\n */\nexport const version: string = \"6.13.5\";\n","/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\n\nfunction checkType(value: any, type: string, name: string): void {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof(value) === type) { return; }\n        }\n    }\n\n    const error: any = new Error(`invalid value for type ${ type }`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${ name }`;\n    error.value = value;\n\n    throw error;\n}\n\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, <{ [ P in keyof T]: T[P] }>{ });\n}\n\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n","/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\nimport { version } from \"../_version.js\";\n\nimport { defineProperties } from \"./properties.js\";\n\nimport type {\n    TransactionRequest, TransactionReceipt, TransactionResponse\n} from \"../providers/index.js\";\n\nimport type { FetchRequest, FetchResponse } from \"./fetch.js\";\n\n/**\n *  An error may contain additional properties, but those must not\n *  conflict with any implicit properties.\n */\nexport type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\" | \"shortMessage\"> & { shortMessage?: string };\n\n\nfunction stringify(value: any): any {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${ stringify(k) }: ${ stringify(value[k]) }`).join(\", \") + \" }\";\n        }\n    }\n\n    return `[ COULD NOT SERIALIZE ]`;\n}\n\n/**\n *  All errors emitted by ethers have an **ErrorCode** to help\n *  identify and coalesce errors to simplify programmatic analysis.\n *\n *  Each **ErrorCode** is the %%code%% proerty of a coresponding\n *  [[EthersError]].\n *\n *  **Generic Errors**\n *\n *  **``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n *\n *  **``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n *\n *  **``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n *\n *  **``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n *\n *  **``\"SERVER_ERROR\"``** - see [[ServerError]]\n *\n *  **``\"TIMEOUT\"``** - see [[TimeoutError]]\n *\n *  **``\"BAD_DATA\"``** - see [[BadDataError]]\n *\n *  **``\"CANCELLED\"``** - see [[CancelledError]]\n *\n *  **Operational Errors**\n *\n *  **``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n *\n *  **``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n *\n *  **Argument Errors**\n *\n *  **``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n *\n *  **``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n *\n *  **``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n *\n *  **``\"VALUE_MISMATCH\"``** - //unused//\n *\n *  **Blockchain Errors**\n *\n *  **``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n *\n *  **``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n *\n *  **``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n *\n *  **``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n *\n *  **``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n *\n *  **``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n *\n *  **``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n *\n *  **User Interaction Errors**\n *\n *  **``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]\n */\nexport type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVALID_ARGUMENT\" | \"MISSING_ARGUMENT\" | \"UNEXPECTED_ARGUMENT\" |\n    \"VALUE_MISMATCH\" |\n\n    // Blockchain Errors\n    \"CALL_EXCEPTION\" | \"INSUFFICIENT_FUNDS\" | \"NONCE_EXPIRED\" |\n    \"REPLACEMENT_UNDERPRICED\" | \"TRANSACTION_REPLACED\" |\n    \"UNCONFIGURED_NAME\" | \"OFFCHAIN_FAULT\" |\n\n    // User Interaction\n    \"ACTION_REJECTED\"\n;\n\n/**\n *  All errors in Ethers include properties to assist in\n *  machine-readable errors.\n */\nexport interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  A short message describing the error, with minimal additional\n     *  details.\n     */\n    shortMessage: string;\n\n    /**\n     *  Additional info regarding the error that may be useful.\n     *\n     *  This is generally helpful mostly for human-based debugging.\n     */\n    info?: Record<string, any>;\n\n    /**\n     *  Any related error.\n     */\n    error?: Error;\n}\n\n// Generic Errors\n\n/**\n *  This Error is a catch-all for when there is no way for Ethers to\n *  know what the underlying problem is.\n */\nexport interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}\n\n/**\n *  This Error is mostly used as a stub for functionality that is\n *  intended for the future, but is currently not implemented.\n */\nexport interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates that the attempted operation is not supported.\n *\n *  This could range from a specific JSON-RPC end-point not supporting\n *  a feature to a specific configuration of an object prohibiting the\n *  operation.\n *\n *  For example, a [[Wallet]] with no connected [[Provider]] is unable\n *  to send a transaction.\n */\nexport interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates a problem connecting to a network.\n */\nexport interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    /**\n     *  The network event.\n     */\n    event: string;\n}\n\n/**\n *  This Error indicates there was a problem fetching a resource from\n *  a server.\n */\nexport interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}\n\n/**\n *  This Error indicates that the timeout duration has expired and\n *  that the operation has been implicitly cancelled.\n *\n *  The side-effect of the operation may still occur, as this\n *  generally means a request has been sent and there has simply\n *  been no response to indicate whether it was processed or not.\n */\nexport interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}\n\n/**\n *  This Error indicates that a provided set of data cannot\n *  be correctly interpreted.\n */\nexport interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}\n\n/**\n *  This Error indicates that the operation was cancelled by a\n *  programmatic call, for example to ``cancel()``.\n */\nexport interface CancelledError extends EthersError<\"CANCELLED\"> {\n}\n\n\n// Operational Errors\n\n/**\n *  This Error indicates an attempt was made to read outside the bounds\n *  of protected data.\n *\n *  Most operations in Ethers are protected by bounds checks, to mitigate\n *  exploits when parsing data.\n */\nexport interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n}\n\n/**\n *  This Error indicates an operation which would result in incorrect\n *  arithmetic output has occurred.\n *\n *  For example, trying to divide by zero or using a ``uint8`` to store\n *  a negative value.\n */\nexport interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}\n\n\n// Argument Errors\n\n/**\n *  This Error indicates an incorrect type or value was passed to\n *  a function or method.\n */\nexport interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}\n\n/**\n *  This Error indicates there were too few arguments were provided.\n */\nexport interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n/**\n *  This Error indicates too many arguments were provided.\n */\nexport interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n\n// Blockchain Errors\n\n/**\n *  The action that resulted in the call exception.\n */\nexport type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"sendTransaction\" | \"unknown\";\n\n/**\n *  The related transaction that caused the error.\n */\nexport type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};\n\n/**\n *  This **Error** indicates a transaction reverted.\n */\nexport interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-readable representation of data, if possible.\n     */\n    reason: null | string;\n\n    /**\n     *  The transaction that triggered the exception.\n     */\n    transaction: CallExceptionTransaction,\n\n    /**\n     *  The contract invocation details, if available.\n     */\n    invocation: null | {\n        method: string;\n        signature: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  The built-in or custom revert error, if available\n     */\n    revert: null | {\n        signature: string;\n        name: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  If the error occurred in a transaction that was mined\n     *  (with a status of ``0``), this is the receipt.\n     */\n    receipt?: TransactionReceipt;   // @TODO: in v7, make this `null | TransactionReceipt`\n}\n\n\n/**\n *  The sending account has insufficient funds to cover the\n *  entire transaction cost.\n */\nexport interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  The sending account has already used this nonce in a\n *  transaction that has been included.\n */\nexport interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A CCIP-read exception, which cannot be recovered from or\n *  be further processed.\n */\nexport interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}\n\n/**\n *  An attempt was made to replace a transaction, but with an\n *  insufficient additional fee to afford evicting the old\n *  transaction from the memory pool.\n */\nexport interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A pending transaction was replaced by another.\n */\nexport interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was replaced.\n     */\n    reason: \"repriced\" | \"cancelled\" | \"replaced\";\n\n    /**\n     *  The hash of the replaced transaction.\n     */\n    hash: string;\n\n    /**\n     *  The transaction that replaced the transaction.\n     */\n    replacement: TransactionResponse;\n\n    /**\n     *  The receipt of the transaction that replace the transaction.\n     */\n    receipt: TransactionReceipt;\n}\n\n/**\n *  This Error indicates an ENS name was used, but the name has not\n *  been configured.\n *\n *  This could indicate an ENS name is unowned or that the current\n *  address being pointed to is the [[ZeroAddress]].\n */\nexport interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}\n\n/**\n *  This Error indicates a request was rejected by the user.\n *\n *  In most clients (such as MetaMask), when an operation requires user\n *  authorization (such as ``signer.sendTransaction``), the client\n *  presents a dialog box to the user. If the user denies the request\n *  this error is thrown.\n */\nexport interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n     *  If there is already a pending request, some clients may indicate\n     *  there is already a ``\"pending\"`` action. This prevents an app\n     *  from spamming the user.\n     */\n    reason: \"expired\" | \"rejected\" | \"pending\"\n}\n\n// Coding; converts an ErrorCode its Typed Error\n\n/**\n *  A conditional type that transforms the [[ErrorCode]] T into\n *  its EthersError type.\n *\n *  @flatworm-skip-docs\n */\nexport type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T extends \"TIMEOUT\" ? TimeoutError:\n    T extends \"BAD_DATA\" ? BadDataError:\n    T extends \"CANCELLED\" ? CancelledError:\n\n    T extends \"BUFFER_OVERRUN\" ? BufferOverrunError:\n    T extends \"NUMERIC_FAULT\" ? NumericFaultError:\n\n    T extends \"INVALID_ARGUMENT\" ? InvalidArgumentError:\n    T extends \"MISSING_ARGUMENT\" ? MissingArgumentError:\n    T extends \"UNEXPECTED_ARGUMENT\" ? UnexpectedArgumentError:\n\n    T extends \"CALL_EXCEPTION\" ? CallExceptionError:\n    T extends \"INSUFFICIENT_FUNDS\" ? InsufficientFundsError:\n    T extends \"NONCE_EXPIRED\" ? NonceExpiredError:\n    T extends \"OFFCHAIN_FAULT\" ? OffchainFaultError:\n    T extends \"REPLACEMENT_UNDERPRICED\" ? ReplacementUnderpricedError:\n    T extends \"TRANSACTION_REPLACED\" ? TransactionReplacedError:\n    T extends \"UNCONFIGURED_NAME\" ? UnconfiguredNameError:\n\n    T extends \"ACTION_REJECTED\" ? ActionRejectedError:\n\n    never;\n\n\n\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}\n\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    let shortMessage = message;\n\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${ stringify(info) }`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") { continue; }\n                const value = <any>(info[<keyof ErrorInfo<T>>key]);\n//                try {\n                    details.push(key + \"=\" + stringify(value));\n//                } catch (error: any) {\n//                console.log(\"MMM\", error.message);\n//                    details.push(key + \"=[could not serialize object]\");\n//                }\n            }\n        }\n        details.push(`code=${ code }`);\n        details.push(`version=${ version }`);\n\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n\n    defineProperties<EthersError>(<EthersError>error, { code });\n\n    if (info) { Object.assign(error, info); }\n\n    if ((<any>error).shortMessage == null) {\n        defineProperties<EthersError>(<EthersError>error, { shortMessage });\n    }\n\n    return <T>error;\n}\n\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}\n\n\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\n\nexport function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\n\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") { throw new Error(\"bad\"); };\n        /* c8 ignore stop */\n\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301)\n            /* c8 ignore start */\n            if (check !== expected) { throw new Error(\"broken\") }\n            /* c8 ignore stop */\n        }\n\n        accum.push(form);\n    } catch(error) { }\n\n    return accum;\n}, <Array<string>>[]);\n\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${ method }from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n","/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n","/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport {\n    getBigInt, getNumber, fromTwos, mask, toBigInt\n} from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\n\nimport type { BigNumberish, BytesLike, Numeric } from \"./index.js\";\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\n\nconst _guard = { };\n\n\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) { Zeros += Zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals: number): bigint {\n    let result = Zeros;\n    while (result.length < decimals) { result += result; }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\n\n\n\n    /*\n     *  Returns a new FixedFormat for %%value%%.\n     *\n     *  If %%value%% is specified as a ``number``, the bit-width is\n     *  128 bits and %%value%% is used for the ``decimals``.\n     *\n     *  A string %%value%% may begin with ``fixed`` or ``ufixed``\n     *  for signed and unsigned respectfully. If no other properties\n     *  are specified, the bit-width is 128-bits with 18 decimals.\n     *\n     *  To specify the bit-width and demicals, append them separated\n     *  by an ``\"x\"`` to the %%value%%.\n     *\n     *  For example, ``ufixed128x18`` describes an unsigned, 128-bit\n     *  wide format with 18 decimals.\n     *\n     *  If %%value%% is an other object, its properties for ``signed``,\n     *  ``width`` and ``decimals`` are checked.\n     */\n\n/**\n *  A description of a fixed-point arithmetic field.\n *\n *  When specifying the fixed format, the values override the default of\n *  a ``fixed128x18``, which implies a signed 128-bit value with 18\n *  decimals of precision.\n *\n *  The alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n *  ``ufixed128x18`` respectively.\n *\n *  When a fixed format string begins with a ``u``, it indicates the field\n *  is unsigned, so any negative values will overflow. The first number\n *  indicates the bit-width and the second number indicates the decimal\n *  precision.\n *\n *  When a ``number`` is used for a fixed format, it indicates the number\n *  of decimal places, and the default width and signed-ness will be used.\n *\n *  The bit-width must be byte aligned and the decimals can be at most 80.\n */\nexport type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};\n\nfunction checkValue(val: bigint, format: _FixedFormat, safeOp?: string): bigint {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        } else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n\n    } else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n\n    return val;\n}\n\ntype _FixedFormat = { signed: boolean, width: number, decimals: number, name: string }\n\nfunction getFormat(value?: FixedFormat): _FixedFormat {\n    if (typeof(value) === \"number\") { value = `fixed128x${value}` }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof(value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v: any = value;\n        const check = (key: string, type: string, defaultValue: any): any => {\n            if (v[key] == null) { return defaultValue; }\n            assertArgument(typeof(v[key]) === type,\n                \"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, v[key]);\n            return v[key];\n        }\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n\n    const name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n    return { signed, width, decimals, name };\n}\n\nfunction toString(val: bigint, decimals: number) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n\n    let str = val.toString();\n\n    // No decimal point for whole values\n    if (decimals === 0) { return (negative + str); }\n\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) { str = Zeros + str; }\n\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n\n    return (negative + str);\n}\n\n\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maintain the magnitude\n    readonly #tens: bigint;\n\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    readonly _value!: string;\n\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, value: bigint, format: any) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n\n        this.#val = value;\n\n        this.#format = format;\n\n        const _value = toString(value, format.decimals);\n\n        defineProperties<FixedNumber>(this, { format: format.name, _value });\n\n        this.#tens = getTens(format.decimals);\n    }\n\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed(): boolean { return this.#format.signed; }\n\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width(): number { return this.#format.width; }\n\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals(): number { return this.#format.decimals; }\n\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value(): bigint { return this.#val; }\n\n    #checkFormat(other: FixedNumber): void {\n        assertArgument(this.format === other.format,\n            \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n\n    #checkValue(val: bigint, safeOp?: string): FixedNumber {\n/*\n        const width = BigInt(this.width);\n        if (this.signed) {\n            const limit = (BN_1 << (width - BN_1));\n            assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n\n            if (val > BN_0) {\n                val = fromTwos(mask(val, width), width);\n            } else {\n                val = -fromTwos(mask(-val, width), width);\n            }\n\n        } else {\n            const masked = mask(val, width);\n            assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n            val = masked;\n        }\n*/\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n\n    #add(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other: FixedNumber): FixedNumber { return this.#add(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other: FixedNumber): FixedNumber { return this.#add(other, \"add\"); }\n\n    #sub(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other: FixedNumber): FixedNumber { return this.#sub(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other: FixedNumber): FixedNumber { return this.#sub(other, \"sub\"); }\n\n    #mul(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other: FixedNumber): FixedNumber { return this.#mul(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other: FixedNumber): FixedNumber { return this.#mul(other, \"mul\"); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other: FixedNumber): FixedNumber {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n\n    #div(o: FixedNumber, safeOp?: string): FixedNumber {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other: FixedNumber): FixedNumber { return this.#div(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other: FixedNumber): FixedNumber { return this.#div(other, \"div\"); }\n\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other: FixedNumber): FixedNumber {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n     cmp(other: FixedNumber): number {\n         let a = this.value, b = other.value;\n\n         // Coerce a and b to the same magnitude\n         const delta = this.decimals - other.decimals;\n         if (delta > 0) {\n             b *= getTens(delta);\n         } else if (delta < 0) {\n             a *= getTens(-delta);\n         }\n\n         // Comnpare\n         if (a < b) { return -1; }\n         if (a > b) { return 1; }\n         return 0;\n     }\n\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n     eq(other: FixedNumber): boolean { return this.cmp(other) === 0; }\n\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n     lt(other: FixedNumber): boolean { return this.cmp(other) < 0; }\n\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n     lte(other: FixedNumber): boolean { return this.cmp(other) <= 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n     gt(other: FixedNumber): boolean { return this.cmp(other) > 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n     gte(other: FixedNumber): boolean { return this.cmp(other) >= 0; }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor(): FixedNumber {\n        let val = this.#val;\n        if (this.#val < BN_0) { val -= this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling(): FixedNumber {\n        let val = this.#val;\n        if (this.#val > BN_0) { val += this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) { return this; }\n\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n\n        checkValue(value, this.#format, \"round\");\n\n        return new FixedNumber(_guard, value, this.#format);\n    }\n\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero(): boolean { return (this.#val === BN_0); }\n\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative(): boolean { return (this.#val < BN_0); }\n\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString(): string { return this._value; }\n\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format: FixedFormat): FixedNumber {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value: BigNumberish, _decimals?: Numeric, _format?: FixedFormat): FixedNumber {\n        const decimals = (_decimals == null) ? 0: getNumber(_decimals);\n        const format = getFormat(_format);\n\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n\n        checkValue(value, format, \"fromValue\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value: string, _format?: FixedFormat): FixedNumber {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n\n        const format = getFormat(_format);\n\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n\n        // Pad out the decimals\n        while (decimal.length < format.decimals) { decimal += Zeros; }\n\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n\n        const value = BigInt(match[1] + whole + decimal)\n\n        checkValue(value, format, \"fromString\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value: BytesLike, _format?: FixedFormat): FixedNumber {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n\n        if (format.signed) { value = fromTwos(value, format.width); }\n\n        checkValue(value, format, \"fromBytes\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n}\n\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n","/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nimport { assertArgument } from \"./errors.js\";\nimport { FixedNumber } from \"./fixednumber.js\";\nimport { getNumber } from \"./maths.js\";\n\nimport type { BigNumberish, Numeric } from \"../utils/index.js\";\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nexport function formatUnits(value: BigNumberish, unit?: string | Numeric): string {\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nexport function parseUnits(value: string, unit?: string | Numeric): bigint {\n    assertArgument(typeof(value) === \"string\", \"value must be a string\", \"value\", value);\n\n    let decimals = 18;\n    if (typeof(unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n\n    return FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nexport function parseEther(ether: string): bigint {\n    return parseUnits(ether, 18);\n}\n"],"names":["supportsWalletNamespace","LruMap","async","sendTransaction","client","parameters","account","account_","chain","accessList","authorizationList","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","value","rest","AccountNotFoundError","docsPath","parseAccount","assertRequest","to","length","recoverAuthorizationAddress","authorization","catch","BaseError","type","chainId","getAction","getChainId","_ref","currentChainId","ChainNotFoundError","id","ChainMismatchError","assertCurrentChain","chainFormat","formatters","transactionRequest","format","request","formatTransactionRequest","extract","from","address","isWalletNamespaceSupported","get","uid","method","params","retryCount","e","error","name","then","hash","set","walletNamespaceError","prepareTransactionRequest","nonceManager","defaultParameters","serializer","serializers","transaction","serializedTransaction","signTransaction","sendRawTransaction","AccountTypeNotSupportedError","metaMessages","err","args","cause","getNodeError","UnknownNodeError","TransactionExecutionError","getTransactionError","undefined","writeContract","abi","dataSuffix","functionName","encodeFunctionData","replace","getContractError","sender","writeContractMutationOptions","config","mutationFn","variables","connector","getClient","getConnectorClient","action","viem_writeContract","mutationKey","useWriteContract","arguments","mutation","mutationOptions","useConfig","mutate","mutateAsync","result","useMutation","writeContractAsync","version","checkType","types","split","map","t","trim","i","Error","code","argument","defineProperties","target","values","key","Object","defineProperty","enumerable","writable","stringify","Array","isArray","join","Uint8Array","HEX","toJSON","toString","BigInt","JSON","keys","sort","k","assert","check","message","info","shortMessage","details","push","TypeError","RangeError","assign","makeError","assertArgument","reduce","accum","form","normalize","String","fromCharCode","_getBytes","copy","match","offset","parseInt","substring","getBytes","BN_0","BN_1","maxValue","fromTwos","_value","_width","getUint","width","getNumber","operation","fault","mask","_bits","bits","getBigInt","Number","isInteger","Nibbles","toBigInt","v","BN_N1","BN_5","_guard","Zeros","getTens","decimals","checkValue","val","safeOp","signed","limit","getFormat","defaultValue","FixedNumber","constructor","guard","givenGuard","className","assertPrivate","this","negative","str","index","other","o","addUnsafe","add","subUnsafe","sub","mulUnsafe","mul","mulSignal","divUnsafe","div","divSignal","cmp","a","b","delta","eq","lt","lte","gt","gte","floor","ceiling","round","bump","tens","isZero","isNegative","toUnsafeFloat","parseFloat","toFormat","fromString","fromValue","_decimals","_format","whole","decimal","fromBytes","names","formatUnits","unit","indexOf","parseUnits","parseEther","ether"],"sourceRoot":""}