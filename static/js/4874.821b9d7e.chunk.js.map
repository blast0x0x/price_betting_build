{"version":3,"file":"static/js/4874.821b9d7e.chunk.js","mappings":"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","sources":["../node_modules/@noble/hashes/src/_u64.ts","../node_modules/@noble/hashes/src/sha3.ts","../node_modules/@noble/hashes/src/crypto.ts","../node_modules/@noble/hashes/src/utils.ts","../node_modules/@noble/hashes/src/_assert.ts"],"sourcesContent":["/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  byteSwap32,\n  Hash,\n  isLE,\n  toBytes,\n  u32,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  type CHash,\n  type CHashXO,\n  type HashXOF,\n  type Input,\n} from './utils.js';\n\n// Various per round constants calculations\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak(): void {\n    if (!isLE) byteSwap32(this.state32);\n    keccakP(this.state32, this.rounds);\n    if (!isLE) byteSwap32(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n// Cast array to view\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): void {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash function */\nexport type CHash = ReturnType<typeof wrapConstructor>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof wrapConstructorWithOpts>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof wrapXOFConstructorWithOpts>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * Internal assertion helpers.\n * @module\n */\n\n/** Asserts something is positive integer. */\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Hash interface. */\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Asserts something is hash */\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, abytes, ahash, aexists, aoutput };\n"],"names":["U32_MASK64","BigInt","_32n","fromBig","n","arguments","length","undefined","h","Number","l","split","lst","le","Ah","Uint32Array","Al","i","rotlSH","s","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","push","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","Hash","constructor","blockLen","suffix","outputLen","enableXOF","rounds","super","pos","posOut","finished","destroyed","anumber","this","Error","state","Uint8Array","state32","u32","keccak","isLE","byteSwap32","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","fill","keccakP","update","data","aexists","len","toBytes","take","Math","min","finish","writeInto","out","abytes","bufferOut","set","subarray","xofInto","xof","bytes","digestInto","aoutput","destroy","digest","_cloneInto","to","gen","wrapConstructor","keccak_256","crypto","globalThis","arr","buffer","byteOffset","floor","byteLength","createView","DataView","rotr","word","byteSwap","hexes","Array","from","_","toString","padStart","bytesToHex","hex","str","TextEncoder","encode","utf8ToBytes","concatBytes","sum","a","res","pad","clone","hashCons","hashC","msg","tmp","create","randomBytes","bytesLength","getRandomValues","isSafeInteger","b","ArrayBuffer","isView","name","_len","lengths","_key","includes","ahash","instance","checkFinished"],"sourceRoot":""}